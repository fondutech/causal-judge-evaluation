@startuml SIMCal_Internal
title SIMCal — Surrogate-Indexed Monotone Calibration (Internals)

skinparam backgroundColor #FFFFFF
skinparam shadowing false
skinparam defaultFontName Inter, Arial
skinparam rectangle {
  RoundCorner 12
  BorderColor #223
  FontColor #111
}
skinparam packageStyle rectangle
skinparam ArrowColor #223
skinparam ArrowThickness 1.5

' ===== INPUTS =====
rectangle "Inputs:\n• S (judge index)\n• W_m1 (mean-one baseline weights)\n• Folds {I_k} (OOF)\n• R (calibrated reward)\n• cap ρ ≥ 1\n• (optional) DR residuals T = R - m̂(X,A)" as IN

' ===== OOF CANDIDATES =====
package "OOF Monotone Candidates" #eef6ff {
  rectangle "IsoUp (↑):\nfit on folds ≠ k,\npredict on k" as UP
  rectangle "IsoDown (↓):\nfit on folds ≠ k,\npredict on k" as DOWN
  rectangle "Base:\nW_m1" as BASE
}

' ===== STACKING =====
package "Stacking on residuals T" #f4f9f4 {
  rectangle "Solve β ∈ Δ₃ to minimize\nVar_n( (β↑·W↑ + β↓·W↓ + β0·W_m1) · T )\n(learned OOF)" as STACK
}

' ===== CAP & REPROJECT =====
package "Variance Cap + Re-project" #fff7e6 {
  rectangle "Blend with quadratic λ:\nW_blend = (1−λ)·W_m1 + λ·W_stack\ns.t. Var_n(W_blend) ≤ ρ·Var_n(W_m1)" as BLEND
  rectangle "Mean-one Isotonic\nPAVA on (S, W_blend)" as MONO
}

' ===== OPTIONAL TARGETING =====
package "Optional Targeted SIMCal (CLT mode)" #ffeef0 {
  rectangle "Affine (a,b) so that:\nE_n[a·W_mono + b] = 1\nE_n[(a·W_mono + b)·R] = E_n[W_m1·R]\nGuards: denom>ε, a>0, nonneg., cap holds" as TARGET
}

' ===== OUTPUT =====
rectangle "Output:\nW_cal (final, mean-one, S-monotone,\ncap-respecting; targeted if enabled)" as OUT

' ===== FLOWS =====
IN --> UP
IN --> DOWN
IN --> BASE
UP --> STACK
DOWN --> STACK
BASE --> STACK
STACK --> BLEND : W_stack
BASE --> BLEND : W_m1
BLEND --> MONO : W_blend
MONO --> TARGET : W_mono
MONO --> OUT
TARGET --> OUT : W_targ (if guards pass)

' ===== NOTES =====
note right of STACK
  Residuals T:
   • IPS mode: T = R
   • DR mode:  T = R − m̂(X,A)
  Cross-fitting used throughout.
end note

note right of BLEND
  λ is the smaller root of
  aλ² + bλ + d ≤ 0:
   a = v1 − 2c + v0
   b = 2(c − v0)
   d = (1−ρ) v0
  where v0=Var(W_m1),
        v1=Var(W_stack),
        c=Cov(W_m1, W_stack).
end note

note bottom of TARGET
  No re-projection after targeting;
  else use Dykstra to project onto
  (mono ∩ mean-one ∩ R-moment).
  Var(aW+b) = a² Var(W) → re-check cap.
end note

@enduml
